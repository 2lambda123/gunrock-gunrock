<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>gunrock: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gunrock
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Gunrock: High-Performance Graph Primitives for the GPU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="contents">
<div class="textblock"><p>A Simple Gunrock Example</p>
<p>This code sample demonstrates a basic usage of Gunrock for finding the largest connected component of a graph, running BFS on this connected component and then computing betweenness centrality values on the GPU.</p>
<h1><a class="anchor" id="codeWalkthrough"></a>
Sample Code Walkthrough</h1>
<p>This simple example shows you how to initialize graph primitive data structures, run the algorithm and extract results.</p>
<p><div class="fragment"><div class="line">    DeviceInit(args);</div>
<div class="line">    cudaSetDeviceFlags(cudaDeviceMapHost);</div>
</div><!-- fragment --></p>
<p>The <code>DeviceInit</code> function will find the device which supports CUDA and initialize it. <code>cudaSetDeviceFlags(cudaDeviceMapHost)</code> will allow us to allocate pinned host memory that is accessible to the device.</p>
<p><div class="fragment"><div class="line">    g_undirected = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">    std::string graph_type = argv[1];</div>
<div class="line">    <span class="keywordtype">int</span> flags = args.ParsedArgc();</div>
<div class="line">    <span class="keywordtype">int</span> graph_args = argc - flags - 1;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (graph_args &lt; 1) {</div>
<div class="line">        Usage();</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>The following few lines will parse the command line arguments, here we set <code>g_undirected</code> to be true to imply that the input graph is undirected.</p>
<p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (graph_type == <span class="stringliteral">&quot;market&quot;</span>) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Matrix-market coordinate-formatted graph file</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">int</span> VertexId;   <span class="comment">// Use as the node identifier type</span></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">float</span> Value;    <span class="comment">// Use as the value type</span></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">int</span> SizeT;      <span class="comment">// Use as the graph size type</span></div>
<div class="line">        Csr&lt;VertexId, Value, SizeT&gt; csr(<span class="keyword">false</span>); <span class="comment">// default value for</span></div>
<div class="line">                                                <span class="comment">// stream_from_host is</span></div>
<div class="line">                                                <span class="comment">// false</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (graph_args &lt; 1) { Usage(); <span class="keywordflow">return</span> 1; }</div>
<div class="line">        <span class="keywordtype">char</span> *market_filename = (graph_args == 2) ? argv[2] : NULL;</div>
<div class="line">        <span class="keywordflow">if</span> (graphio::BuildMarketGraph&lt;false&gt;(</div>
<div class="line">                market_filename,</div>
<div class="line">                csr,</div>
<div class="line">                g_undirected) != 0)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> 1;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        csr.DisplayGraph();</div>
<div class="line">        fflush(stdout);</div>
</div><!-- fragment --></p>
<p>The current version of Gunrock only supports Matrix-market coordinate-formatted graph file. After we set the type info for the node identifier, the graph size and the value to compute. We declare an object <code>csr</code> of <code>Csr&lt;VertexId, Value, SizeT&gt;</code>. <a href="http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29">Compressed sparse row (CSR)</a> data structure is the primary data structure we use in this library. We then use <code>graphio::BuildMarketGraph</code> to build the graph data structure from file. In this example we suppose the graph has no edge weight. <code>DisplayGraph</code> function will display the graph as the CSR data structure.</p>
<p>The main function in this example is <code>RunTests(csr, args)</code>;</p>
<h2><a class="anchor" id="RunTests"></a>
RunTests Function</h2>
<p><code>RunTests</code> starts by declaring problem type and functor types for a graph primitive. We want to compute connected component first.</p>
<p><div class="fragment"><div class="line">    <span class="keyword">typedef</span> CCProblem&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        <span class="keyword">true</span>&gt; CCProblem_T; <span class="comment">//use double buffer for edgemap and vertexmap.</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> UpdateMaskFunctor&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        CCProblem_T&gt; UpdateMaskFunctor;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> HookInitFunctor&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        CCProblem_T&gt; HookInitFunctor;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> HookMinFunctor&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        CCProblem_T&gt; HookMinFunctor;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> HookMaxFunctor&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        CCProblem_T&gt; HookMaxFunctor;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> PtrJumpFunctor&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        CCProblem_T&gt; PtrJumpFunctor;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> PtrJumpMaskFunctor&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        CCProblem_T&gt; PtrJumpMaskFunctor;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> PtrJumpUnmaskFunctor&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        CCProblem_T&gt; PtrJumpUnmaskFunctor;</div>
</div><!-- fragment --></p>
<p>Then we allocate host-side array for reference check and GPU -computed results. We also need to initialize our problem enactor of <code>CCEnactor</code> type. The enactor object contains the enact function which has kernel entries for graph primitive kernel functions.</p>
<p><div class="fragment"><div class="line">    VertexId    *reference_component_ids        =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line">    VertexId    *h_component_ids                =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line">    VertexId    *reference_check                =</div>
<div class="line">        (g_quick) ? NULL : reference_component_ids;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ref_num_components             = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate CC enactor map</span></div>
<div class="line">    CCEnactor&lt;INSTRUMENT&gt; cc_enactor(g_verbose);</div>
</div><!-- fragment --></p>
<p>In the next step, we create a pointer of <code>CCProblem</code> type and initialize it with CSR graph data on host. The problem object will hold data on device for each graph primitive in Gunrock library.</p>
<p><div class="fragment"><div class="line">    CCProblem_T *cc_problem = <span class="keyword">new</span> CCProblem_T;</div>
<div class="line">    <span class="keywordflow">if</span> (cc_problem-&gt;Init(</div>
<div class="line">            g_stream_from_host,</div>
<div class="line">            graph.nodes,</div>
<div class="line">            graph.edges,</div>
<div class="line">            graph.row_offsets,</div>
<div class="line">            graph.column_indices,</div>
<div class="line">            num_gpus)) exit(1);</div>
</div><!-- fragment --></p>
<p>Before computing connected-component on GPU, we first run the <code>RefCPUCC</code> function to get the CPU reference result.</p>
<p><div class="fragment"><div class="line">    <span class="comment">// Compute reference CPU CC solution for source-distance</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (reference_check != NULL)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;compute ref value\n&quot;</span>);</div>
<div class="line">        ref_num_components = <a class="code" href="test__cc_8cu.html#afd4823d968f6198e637586c43db80bf5">RefCPUCC</a>(</div>
<div class="line">            graph.row_offsets,</div>
<div class="line">            graph.column_indices,</div>
<div class="line">            graph.nodes,</div>
<div class="line">            reference_check);</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>Now we can run our connected component primitive on GPU. To record kernel running time, simply define a <code>gpu_timer</code> of <code>GpuTimer</code> type. Note that we need to call the <code>Reset</code> function for each problem before the running of our GPU algorithm. We then call the enact function, and send all the fuctor types we need for this graph primitive to the function as template parameters.</p>
<p><div class="fragment"><div class="line">    <span class="comment">// Perform CC</span></div>
<div class="line">    GpuTimer gpu_timer;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (retval = cc_problem-&gt;Reset(cc_enactor.GetFrontierType(), 1.0)) exit(1);</div>
<div class="line">    gpu_timer.Start();</div>
<div class="line">    <span class="keywordflow">if</span> (retval = cc_enactor.template Enact&lt;CCProblem_T,</div>
<div class="line">        UpdateMaskFunctor,</div>
<div class="line">        HookInitFunctor,</div>
<div class="line">        HookMinFunctor,</div>
<div class="line">        HookMaxFunctor,</div>
<div class="line">        PtrJumpFunctor,</div>
<div class="line">        PtrJumpMaskFunctor,</div>
<div class="line">        PtrJumpUnmaskFunctor&gt;(cc_problem, max_grid_size)) exit(1);</div>
<div class="line">    gpu_timer.Stop();</div>
</div><!-- fragment --></p>
<p>After the connected component GPU function, we need to call <code>Extract</code> function to extract results from device memory. Then we can run some validation code, get the top 10 largest connected components and print their root node ids. We can set the source node for Breadth-First Search as the root of the largest connected component.</p>
<p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (cc_problem-&gt;Extract(h_component_ids)) exit(1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Validity</span></div>
<div class="line">    <span class="keywordflow">if</span> (ref_num_components == cc_problem-&gt;num_components)</div>
<div class="line">        printf(<span class="stringliteral">&quot;CORRECT.\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        printf(<span class="stringliteral">&quot;INCORRECT. Ref Component Count: %d, &quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;GPU Computed Component Count: %d\n&quot;</span>,</div>
<div class="line">               ref_num_components, cc_problem-&gt;num_components);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute size and root of each component</span></div>
<div class="line">    VertexId        *h_roots            =</div>
<div class="line">        <span class="keyword">new</span> VertexId[cc_problem-&gt;num_components];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    *h_histograms       =</div>
<div class="line">        <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[cc_problem-&gt;num_components];</div>
<div class="line"></div>
<div class="line">    cc_problem-&gt;ComputeDetails(h_component_ids, h_roots, h_histograms);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Display Solution</span></div>
<div class="line">    <a class="code" href="simple__example_8cu.html#a61d779ff2d4b978ff1d96f5df14953d0" title="Displays the CC result (i.e., number of components)">DisplayCCSolution</a>(h_component_ids, graph.nodes, ref_num_components);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> CcList&lt;VertexId&gt; CcListType;</div>
<div class="line">    <span class="comment">//sort the components by size</span></div>
<div class="line">    CcListType *cclist =</div>
<div class="line">        (CcListType*)malloc(<span class="keyword">sizeof</span>(CcListType) * ref_num_components);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ref_num_components; ++i)</div>
<div class="line">    {</div>
<div class="line">        cclist[i].root = h_roots[i];</div>
<div class="line">        cclist[i].histogram = h_histograms[i];</div>
<div class="line">    }</div>
<div class="line">    std::stable_sort(cclist, cclist + ref_num_components, CCCompare&lt;CcListType&gt;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Print out at most top 10 largest components</span></div>
<div class="line">    <span class="keywordtype">int</span> top = (ref_num_components &lt; 10) ? ref_num_components : 10;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Top %d largest components:\n&quot;</span>, top);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; top; ++i)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;CC ID: %d, CC Root: %d, CC Size: %d\n&quot;</span>,</div>
<div class="line">               i, cclist[i].root, cclist[i].histogram);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    printf(<span class="stringliteral">&quot;GPU Connected Component finished in %lf msec.\n&quot;</span>, elapsed);</div>
<div class="line"></div>
<div class="line">    VertexId src = cclist[0].root;      <span class="comment">// Set the root of the largest</span></div>
</div><!-- fragment --></p>
<p>The final step of a graph primitive process is cleanup. Note we only need to delete the problem object, the destructor function will release the device memory for us. We finally call the <code>cudaDeviceSynchronize</code> to make sure the device has completed all preceding requested tasks.</p>
<p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (cc_problem) <span class="keyword">delete</span> cc_problem;</div>
<div class="line">    <span class="keywordflow">if</span> (h_roots) <span class="keyword">delete</span>[] h_roots;</div>
<div class="line">    <span class="keywordflow">if</span> (h_histograms) <span class="keyword">delete</span>[] h_histograms;</div>
<div class="line">    <span class="keywordflow">if</span> (cclist) free(cclist);</div>
<div class="line">    <span class="keywordflow">if</span> (reference_component_ids) free(reference_component_ids);</div>
<div class="line">    <span class="keywordflow">if</span> (h_component_ids) free(h_component_ids);</div>
<div class="line"></div>
<div class="line">    cudaDeviceSynchronize();</div>
</div><!-- fragment --></p>
<p>For Breadth-First Search primitive, the process is the same. We first declare the problem type and functor type for BFS.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">bool</span> MARK_PREDECESSORS = <span class="keyword">true</span>; <span class="comment">// Set MARK_PREDECESSORS flag</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> BFSProblem&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        <span class="keyword">true</span>,                <span class="comment">// Set MARK_PREDECESSORS flag true</span></div>
<div class="line">        <span class="keyword">false</span>&gt; BFSProblem_T; <span class="comment">// does not use double buffer</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> BFSFunctor&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        BFSProblem_T&gt; BfsFunctor;</div>
</div><!-- fragment --></p>
<p>Then we allocate host-side array for reference check and GPU -computed results, initialize our problem enactor of <code>BFSEnactor</code> type, run CPU BFS reference algorithm, and load the enact function as we did in CC graph primitive.</p>
<p><div class="fragment"><div class="line">    VertexId *reference_labels =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line">    VertexId *h_labels         =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line">    reference_check            =</div>
<div class="line">        (g_quick) ? NULL : reference_labels;</div>
<div class="line">    VertexId *h_preds          =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate BFS enactor map</span></div>
<div class="line">    BFSEnactor&lt;INSTRUMENT&gt; bfs_enactor(g_verbose);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate problem on GPU</span></div>
<div class="line">    BFSProblem_T *bfs_problem = <span class="keyword">new</span> BFSProblem_T;</div>
<div class="line">    <span class="keywordflow">if</span> (bfs_problem-&gt;Init(</div>
<div class="line">            g_stream_from_host,</div>
<div class="line">            graph.nodes,</div>
<div class="line">            graph.edges,</div>
<div class="line">            graph.row_offsets,</div>
<div class="line">            graph.column_indices,</div>
<div class="line">            num_gpus)) exit(1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Compute reference CPU BFS solution for source-distance</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (reference_check != NULL)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;compute ref value\n&quot;</span>);</div>
<div class="line">        <a class="code" href="test__bfs_8cu.html#a83ce13d27aa3e952b71ed1780fd49e0b">SimpleReferenceBfs</a>(</div>
<div class="line">            graph,</div>
<div class="line">            reference_check,</div>
<div class="line">            src);</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    retval = cudaSuccess;</div>
<div class="line"></div>
<div class="line">    Stats *stats = <span class="keyword">new</span> Stats(<span class="stringliteral">&quot;GPU BFS&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span>           total_queued = 0;</div>
<div class="line">    VertexId            search_depth = 0;</div>
<div class="line">    <span class="keywordtype">double</span>              avg_duty = 0.0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Perform BFS</span></div>
<div class="line">    gpu_timer;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (retval = bfs_problem-&gt;Reset(src, bfs_enactor.GetFrontierType(),</div>
<div class="line">                                    max_queue_sizing)) {</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
<div class="line">    gpu_timer.Start();</div>
<div class="line">    <span class="keywordflow">if</span> (retval = bfs_enactor.template Enact&lt;BFSProblem_T, BfsFunctor&gt;(bfs_problem, src, max_grid_size)) {</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
<div class="line">    gpu_timer.Stop();</div>
<div class="line"></div>
<div class="line">    bfs_enactor.GetStatistics(total_queued, search_depth, avg_duty);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (retval &amp;&amp; (retval != cudaErrorInvalidDeviceFunction)) {</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    elapsed = gpu_timer.ElapsedMillis();</div>
</div><!-- fragment --></p>
<p>The extracting, validation and cleanup code are also quite similar.</p>
<p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (bfs_problem-&gt;Extract(h_labels, h_preds)) exit(1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Verify the result</span></div>
<div class="line">    <span class="keywordflow">if</span> (reference_check != NULL) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Validity: &quot;</span>);</div>
<div class="line">        CompareResults(h_labels, reference_check, graph.nodes, <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    printf(<span class="stringliteral">&quot;\nFirst 40 labels of the GPU result.&quot;</span>);</div>
<div class="line">    <span class="comment">// Display Solution</span></div>
<div class="line">    <a class="code" href="simple__example_8cu.html#a294e71af0083dbbf14b90c514d93960d" title="Displays the BFS result (i.e., distance from source)">DisplayBFSSolution</a>(h_labels, h_preds, graph.nodes, MARK_PREDECESSORS);</div>
<div class="line"></div>
<div class="line">    DisplayBFSStats&lt;true&gt;( <span class="comment">//set MARK_PREDECESSORS flag</span></div>
<div class="line">        *stats,</div>
<div class="line">        src,</div>
<div class="line">        h_labels,</div>
<div class="line">        graph,</div>
<div class="line">        elapsed,</div>
<div class="line">        search_depth,</div>
<div class="line">        total_queued,</div>
<div class="line">        avg_duty);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cleanup</span></div>
<div class="line">    <span class="keyword">delete</span> stats;</div>
<div class="line">    <span class="keywordflow">if</span> (bfs_problem) <span class="keyword">delete</span> bfs_problem;</div>
<div class="line">    <span class="keywordflow">if</span> (reference_labels) free(reference_labels);</div>
<div class="line">    <span class="keywordflow">if</span> (h_labels) free(h_labels);</div>
<div class="line">    <span class="keywordflow">if</span> (h_preds) free(h_preds);</div>
<div class="line"></div>
<div class="line">    cudaDeviceSynchronize();</div>
</div><!-- fragment --></p>
<p>The third graph primitive we want to run is Brandes Betweenness Centrality. We first set the source node to -1 to inform the algorithm to compute the BC values for all nodes in the graph. The preparation steps are similar to the previous two primitives. In the actual computing process, we need to manually iterate over all the nodes in the graph. We design the BC primitive this way to provide more flexible use of BC value computing. For example, you can build your own approximate BC algorithm using this primitive.</p>
<p><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (VertexId i = start_src; i &lt; end_src; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (retval = bc_problem-&gt;Reset(i, bc_enactor.GetFrontierType(),</div>
<div class="line">                                       max_queue_sizing)) {</div>
<div class="line">            exit(1);</div>
<div class="line">        }</div>
<div class="line">        }</div>
</div><!-- fragment --></p>
<p>Note after the algorithm we need to call a scale kernel for normalization.</p>
<p><div class="fragment"><div class="line">    util::MemsetScaleKernel&lt;&lt;&lt;128, 128&gt;&gt;&gt;</div>
</div><!-- fragment --></p>
<p>The final step is the cleanup code for BC primitive.</p>
<p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (bc_problem) <span class="keyword">delete</span> bc_problem;</div>
<div class="line">    <span class="keywordflow">if</span> (reference_bc_values) free(reference_bc_values);</div>
<div class="line">    <span class="keywordflow">if</span> (h_bc_values) free(h_bc_values);</div>
<div class="line"></div>
<div class="line">    cudaDeviceSynchronize();</div>
</div><!-- fragment --></p>
<p>We hope this can help you to integrate Gunrock into your project. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 10 2013 14:33:36 for gunrock by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
