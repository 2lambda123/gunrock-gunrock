<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>gunrock: A Simple Gunrock Example</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">gunrock
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">Gunrock: High-Performance Graph Primitives for the GPU</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">A Simple Gunrock Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This code sample demonstrates basic usage of Gunrock for finding the largest connected component of a graph, running BFS on this connected component, and then computing betweenness-centrality values, all on the GPU.</p>
<h2><a class="anchor" id="codeWalkthrough"></a>
Sample Code Walkthrough</h2>
<p>This simple example shows you how to initialize graph primitive data structures, run the algorithm, and extract results. The following description first shows each block of code and then explains it.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> dev = 0;
    args.GetCmdLineArgument(<span class="stringliteral">&quot;device&quot;</span>, dev);
    ContextPtr context = mgpu::CreateCudaDevice(dev);
</pre></div></p>
<p>The <code>mgpu::CreateCudaDevice</code> function finds the device that supports CUDA and initializes it.</p>
<p><div class="fragment"><pre class="fragment">    g_undirected = <span class="keyword">true</span>;

    std::string graph_type = argv[1];
    <span class="keywordtype">int</span> flags = args.ParsedArgc();
    <span class="keywordtype">int</span> graph_args = argc - flags - 1;

    <span class="keywordflow">if</span> (graph_args &lt; 1) {
        Usage();
        <span class="keywordflow">return</span> 1;
    }
</pre></div></p>
<p>The above chunk of code will parse the command line arguments. In this example, we set <code>g_undirected</code> to be true to imply that the input graph is undirected.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> (graph_type == <span class="stringliteral">&quot;market&quot;</span>) {

        <span class="comment">// Matrix-market coordinate-formatted graph file</span>

        <span class="keyword">typedef</span> <span class="keywordtype">int</span> VertexId;   <span class="comment">// Use as the node identifier type</span>
        <span class="keyword">typedef</span> <span class="keywordtype">float</span> Value;    <span class="comment">// Use as the value type</span>
        <span class="keyword">typedef</span> <span class="keywordtype">int</span> SizeT;      <span class="comment">// Use as the graph size type</span>
        Csr&lt;VertexId, Value, SizeT&gt; csr(<span class="keyword">false</span>); <span class="comment">// default value for</span>
                                                <span class="comment">// stream_from_host is</span>
                                                <span class="comment">// false</span>

        <span class="keywordflow">if</span> (graph_args &lt; 1) { Usage(); <span class="keywordflow">return</span> 1; }
        <span class="keywordtype">char</span> *market_filename = (graph_args == 2) ? argv[2] : NULL;
        <span class="keywordflow">if</span> (graphio::BuildMarketGraph&lt;false&gt;(
                market_filename,
                csr,
                g_undirected,
                <span class="keyword">false</span>) != 0) <span class="comment">// no inverse graph</span>
        {
            <span class="keywordflow">return</span> 1;
        }

        <span class="comment">// csr.DisplayGraph();</span>
        fflush(stdout);
</pre></div></p>
<p>The current version of Gunrock only supports input graphs stored in matrix-market coordinate-formatted files. When we read a graph from a file, we must store it into a data structure. Gunrock uses a <a href="http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29">compressed sparse row (CSR)</a> data structure internally. Before we define this CSR data structure, we must define the datatypes in this data structure. In general, we need three datatypes in our CSR data structure.</p>
<ul>
<li><code>VertexId</code> is used as the node identifier type; here we set it as <code>int</code>.</li>
<li><code>Value</code> is used as the datatype of a value attached to edge or node in the graph. Here we set it as <code>float</code>. Most of the time, either <code>VertexId</code> or <code>Value</code> will serve as the datatype for any computational results we get from the graph algorithm.</li>
<li><code>SizeT</code> datatype is used as the datatype for storing the number of nodes in the graph and the number of edges in the graph. We usually set it as <code>int</code> or <code> unsigned long </code>.</li>
</ul>
<p>We then define an object with the default argument <code>stream_from_host</code> <code>false</code>. This will disable streaming from host memory when we later populate the object with data. <code><a class="el" href="group___public.html#ga09d0a86cc3e6c1cec6bb26eae9f6c4a0" title="Loads a MARKET-formatted CSR graph from the specified file.">BuildMarketGraph()</a></code> reads from a Matrix Market-stored file into a CSR data structure. In this example, we suppose the graph has no edge weight, so we use <code>false</code> as the template argument. As a test utility function, <code>DisplayGraph()</code> will display the first 40 nodes and their neighbor lists in the graph in the following format:</p>
<p><code> <br/>
node_id_0: neighbor_node_id_0, neighbor_node_id_1, ..., neighbor_node_id_n <br/>
node_id_1: neighbor_node_id_0, neighbor_node_id_1, ..., neighbor_node_id_n <br/>
... </code></p>
<p>The main function in this example is <code>RunTests(csr, args)</code>.</p>
<h3><a class="anchor" id="RunTests"></a>
RunTests Function</h3>
<p><code>RunTests</code> starts by defining the problem data structure for a graph primitive. A problem data structure stores the graph structural data, edge or node value data, and all other data we need for running the graph algorithm. It has four template arguments. We have explained the first three arguments in the previous section; the last argument is a boolean flag that specifies whether we need only one set of ping-pong storage or two. A set of ping-pong storage contains two buffers for storing both the input and the output queue for a GPU kernel function. At the beginning of the first iteration of the GPU kernel function call, we put the input data in one queue of the ping-pong storage; after the first function call, we store the output in the other queue of the ping-pong storage. In the next iteration of the GPU kernel function call, we switch the two queues, using the output of the previous function call as the input of the new function call. Among all three graph primitives currently in Gunrock, only connected-component needs two sets of ping-pong storage; the other two primitives only need one set of ping-pong storage.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> CCProblem&lt;
        VertexId,
        SizeT,
        Value,
        <span class="keyword">true</span>&gt; CCProblem_T; <span class="comment">//use double buffer for edgemap and vertexmap.</span>
</pre></div></p>
<p>Then we allocate host-side arrays for reference check and GPU-computed results. For the connected component primitive, there is only one output array from the GPU computed result: the component ID for each node. To actually run the graph algorithm on the GPU, we need to define a <code>CCEnactor</code> object. An enactor class serves as the manager of the running of a graph algorithm. Gunrock divides a graph algorithm into several device functions running on the GPU. We call such functions kernel functions. Each graph algorithm may consist a set of kernel functions. The enactor class manages how we run these functions to get the results. It also collects statistical data for these kernel functions, such as running time, total elements sent to kernel functions, and the load balancing matric (average duty). The template argument <code>INSTRUMENT</code> is a boolean flag that specifies whether we want to keep such statistical data.</p>
<p><div class="fragment"><pre class="fragment">    VertexId    *reference_component_ids        =
        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);
    VertexId    *h_component_ids                =
        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);
    VertexId    *reference_check                =
        (g_quick) ? NULL : reference_component_ids;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ref_num_components             = 0;

    <span class="comment">// Allocate CC enactor</span>
    CCEnactor&lt;INSTRUMENT&gt; cc_enactor(g_verbose);
</pre></div></p>
<p>In the next step, we create a pointer of the <code>CCProblem</code> type. The <a class="el" href="group___public_interface.html#ga5a0e77eab324d6c54215bbb64ed4a4fc" title="initialization function.">gunrock::app::cc::CCProblem::Init()</a> function will first copy all the graph-related data from CPU to GPU and then initialize other data members in <a class="el" href="structgunrock_1_1app_1_1cc_1_1_c_c_problem_1_1_data_slice.html" title="Data slice structure which contains CC problem specific data.">gunrock::app::cc::CCProblem::DataSlice</a>. After this we will be ready to run the graph algorithm on the GPU.</p>
<p><div class="fragment"><pre class="fragment">    CCProblem_T *cc_problem = <span class="keyword">new</span> CCProblem_T;
    util::GRError(cc_problem-&gt;Init(
                      g_stream_from_host,
                      graph,
                      num_gpus),
</pre></div></p>
<p>We next compute the reference solution for CC on the CPU, storing the result in <code>reference_check</code>.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// Compute reference CPU CC solution for source-distance</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (reference_check != NULL)
        {
            printf(<span class="stringliteral">&quot;compute ref value\n&quot;</span>);
            ref_num_components = <a class="code" href="test__cc_8cu.html#a9f4938b79ad7e2e1ceff1c15759dba66" title="CPU-based reference CC algorithm using Boost Graph Library.">RefCPUCC</a>(
                graph.row_offsets,
                graph.column_indices,
                graph.nodes,
                reference_check);
            printf(<span class="stringliteral">&quot;\n&quot;</span>);
        }
</pre></div></p>
<p>Now we can run the connected component primitive on the GPU. To record the kernel running time, simply define a <code>gpu_timer</code> of <code>GpuTimer</code> type. Note that we need to call the <a class="el" href="group___public_interface.html#gae1592f8c4b124ee7d649665b5b18d24f" title="Reset problem function. Must be called prior to each run.">gunrock::app::cc::CCProblem::Reset()</a> function before the <code>Enact</code> function to reset values in <a class="el" href="structgunrock_1_1app_1_1cc_1_1_c_c_problem_1_1_data_slice.html" title="Data slice structure which contains CC problem specific data.">gunrock::app::cc::CCProblem::DataSlice</a>. The <a class="el" href="group___public_interface.html#ga5066cac5a3c350f47227a11fa784fabc" title="CC Enact kernel entry.">gunrock::app::cc::CCEnactor::Enact()</a> takes a pointer of <a class="el" href="structgunrock_1_1app_1_1cc_1_1_c_c_problem.html" title="Connected Component Problem structure stores device-side vectors for doing connected component comput...">gunrock::app::cc::CCProblem</a> type as the input, runs the connected component primitive, and stores the result in gunrock::app::cc::CCProblem::DataSlice::d_component_ids. We store the GPU running time in a <code>float</code> variable <code>elapsed</code>.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// Perform CC</span>
    GpuTimer gpu_timer;

    util::GRError(
        cc_problem-&gt;Reset(cc_enactor.GetFrontierType()),
        <span class="stringliteral">&quot;CC Problem Data Reset Failed&quot;</span>, __FILE__, __LINE__);
    gpu_timer.Start();
    util::GRError(
        cc_enactor.Enact(cc_problem, max_grid_size),
        <span class="stringliteral">&quot;CC Problem Enact Failed&quot;</span>, __FILE__, __LINE__);
    gpu_timer.Stop();

    <span class="keywordtype">float</span> elapsed = gpu_timer.ElapsedMillis();
</pre></div></p>
<p>After the <code>Enact</code> function, we need to copy the result from the <code>cc_problem</code> data structure on the GPU into <code>h_component_ids</code>. We can further call <a class="el" href="group___public_interface.html#gadfff5070a7e802070a1cae1583cd7939" title="Compute histogram for component ids.">gunrock::app::cc::CCProblem::ComputeCCHistogram()</a> to compute the histogram for the connected components of the graph. Finally we can run some validation code, get the top 10 largest connected components, and print their root node ids. <a class="el" href="simple__example_8cu.html#a61d779ff2d4b978ff1d96f5df14953d0" title="Displays the CC result (i.e., number of components)">DisplayCCSolution()</a> will print the component ids of the first 40 nodes for testing purpose. Now we can set the source node for Breadth-First Search as the root of the largest connected component.</p>
<p><div class="fragment"><pre class="fragment">        cc_problem-&gt;Extract(h_component_ids),
        <span class="stringliteral">&quot;CC Problem Data Extraction Failed&quot;</span>, __FILE__, __LINE__);

    <span class="keywordtype">int</span> num_errors = 0;
    <span class="comment">// Validity</span>
    <span class="keywordflow">if</span> (ref_num_components == cc_problem-&gt;num_components)
        printf(<span class="stringliteral">&quot;CORRECT.\n&quot;</span>);
    <span class="keywordflow">else</span> {
        printf(<span class="stringliteral">&quot;INCORRECT. Ref Component Count: %d, &quot;</span>
               <span class="stringliteral">&quot;GPU Computed Component Count: %d\n&quot;</span>,
               ref_num_components, cc_problem-&gt;num_components);
        printf(<span class="stringliteral">&quot;TEST FAILED\n&quot;</span>);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">// Compute size and root of each component</span>
    VertexId        *h_roots            =
        <span class="keyword">new</span> VertexId[cc_problem-&gt;num_components];
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    *h_histograms       =
        <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[cc_problem-&gt;num_components];

    cc_problem-&gt;ComputeCCHistogram(h_component_ids, h_roots, h_histograms);

    <span class="comment">// Display Solution</span>
    <a class="code" href="simple__example_8cu.html#a61d779ff2d4b978ff1d96f5df14953d0" title="Displays the CC result (i.e., number of components)">DisplayCCSolution</a>(h_component_ids, graph.nodes, ref_num_components);

    <span class="keyword">typedef</span> CcList&lt;VertexId&gt; CcListType;
    <span class="comment">//sort the components by size</span>
    CcListType *cclist =
        (CcListType*)malloc(<span class="keyword">sizeof</span>(CcListType) * ref_num_components);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ref_num_components; ++i) {
        cclist[i].root = h_roots[i];
        cclist[i].histogram = h_histograms[i];
    }
    std::stable_sort(
        cclist, cclist + ref_num_components, CCCompare&lt;CcListType&gt;);

    <span class="comment">// Print out at most top 10 largest components</span>
    <span class="keywordtype">int</span> top = (ref_num_components &lt; 10) ? ref_num_components : 10;
    printf(<span class="stringliteral">&quot;Top %d largest components:\n&quot;</span>, top);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; top; ++i)
        {
            printf(<span class="stringliteral">&quot;CC ID: %d, CC Root: %d, CC Size: %d\n&quot;</span>,
                   i, cclist[i].root, cclist[i].histogram);
        }

    printf(<span class="stringliteral">&quot;GPU Connected Component finished in %lf msec.\n&quot;</span>, elapsed);

    VertexId src = cclist[0].root;      <span class="comment">// Set the root of the largest</span>
</pre></div></p>
<p>The final step of a graph primitive process is cleanup. Note we only need to delete the problem object; its destructor function will release the device memory for us. We finally call <code>cudaDeviceSynchronize</code> to make sure the GPU device has completed all preceding requested tasks.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keyword">delete</span> cc_problem;
    <span class="keyword">delete</span>[] h_roots;
    <span class="keyword">delete</span>[] h_histograms;
    free(cclist);
    free(reference_component_ids);
    free(h_component_ids);

    cudaDeviceSynchronize();
</pre></div></p>
<p>For Breadth-First Search primitive, the process is the same. We first define a pointer to the <a class="el" href="structgunrock_1_1app_1_1bfs_1_1_b_f_s_problem.html" title="Breadth-First Search Problem structure stores device-side vectors for doing BFS computing on the GPU...">gunrock::app::bfs::BFSProblem</a> type. Here we set the template argument <code>MARK_PREDECESSORS</code> to <code>true</code> to specify that we want the algorithm to keep both the distances from source and the predecessor node id as the result.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> BFSProblem&lt;
        VertexId,
        SizeT,
        Value,
        <span class="keyword">false</span>,               <span class="comment">// Set MARK_PREDECESSORS flag true</span>
        <span class="keyword">true</span>,                <span class="comment">// Set to enable idempotent operation</span>
        <span class="keyword">false</span>&gt; BFSProblem_T; <span class="comment">// does not use double buffer</span>
</pre></div></p>
<p>Then we allocate a host-side array for doing a reference check and storing GPU-computed results. For BFS, the results include gunrock::app::bfs::BFSProblem::DataSlice::d_labels and gunrock::app::bfs::BFSProblem::DataSlice::d_preds. We then define the BFS enactor object of the <a class="el" href="classgunrock_1_1app_1_1bfs_1_1_b_f_s_enactor.html" title="Problem enactor class.">gunrock::app::bfs::BFSEnactor</a> type, initialize the <a class="el" href="structgunrock_1_1app_1_1bfs_1_1_b_f_s_problem.html" title="Breadth-First Search Problem structure stores device-side vectors for doing BFS computing on the GPU...">gunrock::app::bfs::BFSProblem</a> type BFS problem object, and run the CPU and the GPU BFS reference algorithm, similar to what we did in the CC graph primitive. If the template argument <code>INSTRUMENT</code> is set, we can use the <code>GetStatistics</code> function to get total elements queued, average kernel duty (a load balancing metric), and for BFS, the searching depth from the enactor object. In this example, we only show how to get statistical data and display it for BFS problem, but all three graph primitives have <code>GetStatistics</code> functions as public interfaces users can call.</p>
<p><div class="fragment"><pre class="fragment">    VertexId *reference_labels =
        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);
    VertexId *h_labels         =
        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);
    reference_check            =
        (g_quick) ? NULL : reference_labels;
    VertexId *h_preds          =
        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);


    <span class="comment">// Allocate BFS enactor</span>
    BFSEnactor&lt;INSTRUMENT&gt; bfs_enactor(g_verbose);

    <span class="comment">// Allocate problem on GPU</span>
    BFSProblem_T *bfs_problem = <span class="keyword">new</span> BFSProblem_T;
    util::GRError(bfs_problem-&gt;Init(
                      g_stream_from_host,
                      graph,
                      num_gpus),
                  <span class="stringliteral">&quot;BFS Problem Initialization Failed&quot;</span>, __FILE__, __LINE__);

    <span class="comment">//</span>
    <span class="comment">// Compute reference CPU BFS solution for source-distance</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (reference_check != NULL)
        {
            printf(<span class="stringliteral">&quot;compute ref value\n&quot;</span>);
            <a class="code" href="test__bfs_8cu.html#ad1bca019227317c51f30e1118e2ad50f" title="A simple CPU-based reference BFS ranking implementation.">SimpleReferenceBfs</a>(
                graph,
                reference_check,
                src);
            printf(<span class="stringliteral">&quot;\n&quot;</span>);
        }

    <a class="code" href="struct_stats.html" title="Performance / Evaluation statistics.">Stats</a> *stats = <span class="keyword">new</span> <a class="code" href="struct_stats.html" title="Performance / Evaluation statistics.">Stats</a>(<span class="stringliteral">&quot;GPU BFS&quot;</span>);

    <span class="keywordtype">long</span> <span class="keywordtype">long</span>           total_queued = 0;
    VertexId            search_depth = 0;
    <span class="keywordtype">double</span>              avg_duty = 0.0;

    <span class="comment">// Perform BFS</span>

    util::GRError(
        bfs_problem-&gt;Reset(src,bfs_enactor.GetFrontierType(), max_queue_sizing),
        <span class="stringliteral">&quot;BFS Problem Data Reset Failed&quot;</span>, __FILE__, __LINE__);
    gpu_timer.Start();
    util::GRError(
        bfs_enactor.Enact(context, bfs_problem, src, max_grid_size),
        <span class="stringliteral">&quot;BFS Problem Enact Failed&quot;</span>, __FILE__, __LINE__);
    gpu_timer.Stop();

    bfs_enactor.GetStatistics(total_queued, search_depth, avg_duty);

    elapsed = gpu_timer.ElapsedMillis();
</pre></div></p>
<p>When we finish the BFS algorithm, we copy the results from GPU to CPU using <code>Extract</code> function. We also use <a class="el" href="group___public_interface.html#gaa265a7f86ad4b06dcb7b5e75869fe7ad" title="Compares the equivalence of two arrays. If incorrect, print the location of the first incorrect value...">gunrock::util::CompareResults()</a> to validate the computed results we get. Here we only do this for the distance from the source value of each node. The <code><a class="el" href="simple__example_8cu.html#a294e71af0083dbbf14b90c514d93960d" title="Displays the BFS result (i.e., distance from source)">DisplayBFSSolution()</a></code> function will display the distance from source value and the predecessor id value for the first 40 nodes in the graph. The <code><a class="el" href="simple__example_8cu.html#a73cc366e897f1aee0f0025548e7c2d82" title="Displays timing and correctness statistics for BFS.">DisplayBFSStats()</a></code> function will display the total queued element number, the maximum search depth, and the average GPU kernel function duty. Users can also implement their own version of these display functions.</p>
<p><div class="fragment"><pre class="fragment">        bfs_problem-&gt;Extract(h_labels, h_preds),
        <span class="stringliteral">&quot;BFS Problem Data Extraction Failed&quot;</span>, __FILE__, __LINE__);

    <span class="comment">// Verify the result</span>
    <span class="keywordflow">if</span> (reference_check != NULL) {
        printf(<span class="stringliteral">&quot;Validity: &quot;</span>);
        num_errors += <a class="code" href="group___public_interface.html#gaa265a7f86ad4b06dcb7b5e75869fe7ad" title="Compares the equivalence of two arrays. If incorrect, print the location of the first incorrect value...">CompareResults</a>(h_labels, reference_check, graph.nodes);
    }
    printf(<span class="stringliteral">&quot;\nFirst 40 labels of the GPU result.&quot;</span>);
    <span class="comment">// Display Solution</span>
    <a class="code" href="simple__example_8cu.html#a294e71af0083dbbf14b90c514d93960d" title="Displays the BFS result (i.e., distance from source)">DisplayBFSSolution</a>(h_labels, h_preds, graph.nodes, <span class="keyword">true</span>);

    <a class="code" href="simple__example_8cu.html#a73cc366e897f1aee0f0025548e7c2d82" title="Displays timing and correctness statistics for BFS.">DisplayBFSStats</a>(
        *stats,
        src,
        h_labels,
        graph,
        elapsed,
        search_depth,
        total_queued,
        avg_duty);


    <span class="comment">// Cleanup</span>
    <span class="keyword">delete</span> stats;
    <span class="keyword">delete</span> bfs_problem;
    free(reference_labels);
    free(h_labels);
    free(h_preds);

    cudaDeviceSynchronize();
</pre></div></p>
<p>The third graph primitive we want to run is Brandes's Betweenness Centrality. We first set the source node to -1 to inform the algorithm to compute the BC values for all nodes in the graph. The preparation steps are similar to those of the previous two primitives.</p>
<p><div class="fragment"><pre class="fragment">    src = -1;
    <span class="keyword">typedef</span> BCProblem&lt;
        VertexId,
        SizeT,
        Value,
        <span class="keyword">true</span>,               <span class="comment">// MARK_PREDECESSOR</span>
        <span class="keyword">false</span>&gt; BCProblem_T; <span class="comment">//does not use double buffer</span>

    <span class="comment">// Allocate host-side array (for both reference and gpu-computed results)</span>
    Value *reference_bc_values       =
        (Value*)malloc(<span class="keyword">sizeof</span>(Value) * graph.nodes);
    Value *h_bc_values               =
        (Value*)malloc(<span class="keyword">sizeof</span>(Value) * graph.nodes);
    Value *reference_check_bc_values = (g_quick) ? NULL : reference_bc_values;

    <span class="comment">// Allocate BC enactor</span>
    BCEnactor&lt;INSTRUMENT&gt; bc_enactor(g_verbose);

    <span class="comment">// Allocate problem on GPU</span>
    BCProblem_T *bc_problem = <span class="keyword">new</span> BCProblem_T;
    util::GRError(bc_problem-&gt;Init(
                      g_stream_from_host,
                      graph,
                      num_gpus),
                  <span class="stringliteral">&quot;BC Problem Initialization Failed&quot;</span>, __FILE__, __LINE__);
</pre></div></p>
<p>In the actual computing process, we need to manually iterate over all the nodes in the graph. We design the BC primitive this way to provide more flexible use of BC value computing. For example, you can build your own approximate BC algorithm using this primitive.</p>
<p><div class="fragment"><pre class="fragment">    VertexId start_src = 0;
    VertexId end_src = graph.nodes;

    gpu_timer.Start();
    <span class="keywordflow">for</span> (VertexId i = start_src; i &lt; end_src; ++i)
        {
            util::GRError(
                bc_problem-&gt;Reset(i, bc_enactor.GetFrontierType(), max_queue_sizing),
                <span class="stringliteral">&quot;BC Problem Data Reset Failed&quot;</span>, __FILE__, __LINE__);
            util::GRError(
                bc_enactor.Enact(context, bc_problem, i, max_grid_size),
                <span class="stringliteral">&quot;BC Problem Enact Failed&quot;</span>, __FILE__, __LINE__);
        }
</pre></div></p>
<p>Note after the algorithm we need to call <a class="el" href="group___public_interface.html#ga1126888b2cf4869c00b90c7adace53c4" title="Scale each element in a device vector to a certain factor.">gunrock::util::MemsetScaleKernel()</a> for normalization. Because we consider the graph as undirected, each node's BC value is thus doubled, so we need to halve them to get the correct values.</p>
<p><div class="fragment"><pre class="fragment">    util::MemsetScaleKernel&lt;&lt;&lt;128, 128&gt;&gt;&gt;
</pre></div></p>
<p>The final step is the cleanup code for the BC primitive.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keyword">delete</span> bc_problem;
    free(reference_bc_values);
    free(h_bc_values);

    cudaDeviceSynchronize();
</pre></div></p>
<p>We hope this can help you to integrate Gunrock into your project. </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 22 2015 07:11:03 for gunrock by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
