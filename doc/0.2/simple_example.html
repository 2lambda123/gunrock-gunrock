<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>gunrock: A Simple Gunrock Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gunrock
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Gunrock: High-Performance Graph Primitives for the GPU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">A Simple Gunrock Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This code sample demonstrates basic usage of Gunrock for finding the largest connected component of a graph, running BFS on this connected component, and then computing betweenness-centrality values, all on the GPU.</p>
<h1><a class="anchor" id="codeWalkthrough"></a>
Sample Code Walkthrough</h1>
<p>This simple example shows you how to initialize graph primitive data structures, run the algorithm, and extract results. The following description first shows each block of code and then explains it.</p>
<p><div class="fragment"><div class="line">    <span class="keywordtype">int</span> dev = 0;</div>
<div class="line">    args.GetCmdLineArgument(<span class="stringliteral">&quot;device&quot;</span>, dev);</div>
<div class="line">    ContextPtr context = mgpu::CreateCudaDevice(dev);</div>
</div><!-- fragment --></p>
<p>The <code>mgpu::CreateCudaDevice</code> function finds the device that supports CUDA and initializes it.</p>
<p><div class="fragment"><div class="line">    g_undirected = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">    std::string graph_type = argv[1];</div>
<div class="line">    <span class="keywordtype">int</span> flags = args.ParsedArgc();</div>
<div class="line">    <span class="keywordtype">int</span> graph_args = argc - flags - 1;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (graph_args &lt; 1) {</div>
<div class="line">        Usage();</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>The above chunk of code will parse the command line arguments. In this example, we set <code>g_undirected</code> to be true to imply that the input graph is undirected.</p>
<p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (graph_type == <span class="stringliteral">&quot;market&quot;</span>) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Matrix-market coordinate-formatted graph file</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">int</span> VertexId;   <span class="comment">// Use as the node identifier type</span></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">float</span> Value;    <span class="comment">// Use as the value type</span></div>
<div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">int</span> SizeT;      <span class="comment">// Use as the graph size type</span></div>
<div class="line">        Csr&lt;VertexId, Value, SizeT&gt; csr(<span class="keyword">false</span>); <span class="comment">// default value for</span></div>
<div class="line">                                                <span class="comment">// stream_from_host is</span></div>
<div class="line">                                                <span class="comment">// false</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (graph_args &lt; 1) { Usage(); <span class="keywordflow">return</span> 1; }</div>
<div class="line">        <span class="keywordtype">char</span> *market_filename = (graph_args == 2) ? argv[2] : NULL;</div>
<div class="line">        <span class="keywordflow">if</span> (graphio::BuildMarketGraph&lt;false&gt;(</div>
<div class="line">                market_filename,</div>
<div class="line">                csr,</div>
<div class="line">                g_undirected,</div>
<div class="line">                <span class="keyword">false</span>) != 0) <span class="comment">// no inverse graph</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> 1;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        csr.DisplayGraph();</div>
<div class="line">        fflush(stdout);</div>
</div><!-- fragment --></p>
<p>The current version of Gunrock only supports input graphs stored in matrix-market coordinate-formatted files. When we read a graph from a file, we must store it into a data structure. Gunrock uses a <a href="http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29">compressed sparse row (CSR)</a> data structure internally. Before we define this CSR data structure, we must define the datatypes in this data structure. In general, we need three datatypes in our CSR data structure.</p><ul>
<li><code>VertexId</code> is used as the node identifier type; here we set it as <code>int</code>.</li>
<li><code>Value</code> is used as the datatype of a value attached to edge or node in the graph. Here we set it as <code>float</code>. Most of the time, either <code>VertexId</code> or <code>Value</code> will serve as the datatype for any computational results we get from the graph algorithm.</li>
<li><code>SizeT</code> datatype is used as the datatype for storing the number of nodes in the graph and the number of edges in the graph. We usually set it as <code>int</code> or <code> unsigned long </code>.</li>
</ul>
<p>We then define an object with the default argument <code>stream_from_host</code> <code>false</code>. This will disable streaming from host memory when we later populate the object with data. <code><a class="el" href="group___public_interface.html#ga09d0a86cc3e6c1cec6bb26eae9f6c4a0" title="Loads a MARKET-formatted CSR graph from the specified file. ">BuildMarketGraph()</a></code> reads from a Matrix Market-stored file into a CSR data structure. In this example, we suppose the graph has no edge weight, so we use <code>false</code> as the template argument. As a test utility function, <code>DisplayGraph()</code> will display the first 40 nodes and their neighbor lists in the graph in the following format:</p>
<p><code> <br />
node_id_0: neighbor_node_id_0, neighbor_node_id_1, ..., neighbor_node_id_n <br />
node_id_1: neighbor_node_id_0, neighbor_node_id_1, ..., neighbor_node_id_n <br />
... </code></p>
<p>The main function in this example is <code>RunTests(csr, args)</code>.</p>
<h2><a class="anchor" id="RunTests"></a>
RunTests Function</h2>
<p><code>RunTests</code> starts by defining the problem data structure for a graph primitive. A problem data structure stores the graph structural data, edge or node value data, and all other data we need for running the graph algorithm. It has four template arguments. We have explained the first three arguments in the previous section; the last argument is a boolean flag that specifies whether we need only one set of ping-pong storage or two. A set of ping-pong storage contains two buffers for storing both the input and the output queue for a GPU kernel function. At the beginning of the first iteration of the GPU kernel function call, we put the input data in one queue of the ping-pong storage; after the first function call, we store the output in the other queue of the ping-pong storage. In the next iteration of the GPU kernel function call, we switch the two queues, using the output of the previous function call as the input of the new function call. Among all three graph primitives currently in Gunrock, only connected-component needs two sets of ping-pong storage; the other two primitives only need one set of ping-pong storage.</p>
<p><div class="fragment"><div class="line">    <span class="keyword">typedef</span> CCProblem&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        <span class="keyword">true</span>&gt; CCProblem_T; <span class="comment">//use double buffer for edgemap and vertexmap.</span></div>
</div><!-- fragment --></p>
<p>Then we allocate host-side arrays for reference check and GPU-computed results. For the connected component primitive, there is only one output array from the GPU computed result: the component ID for each node. To actually run the graph algorithm on the GPU, we need to define a <code>CCEnactor</code> object. An enactor class serves as the manager of the running of a graph algorithm. Gunrock divides a graph algorithm into several device functions running on the GPU. We call such functions kernel functions. Each graph algorithm may consist a set of kernel functions. The enactor class manages how we run these functions to get the results. It also collects statistical data for these kernel functions, such as running time, total elements sent to kernel functions, and the load balancing matric (average duty). The template argument <code>INSTRUMENT</code> is a boolean flag that specifies whether we want to keep such statistical data.</p>
<p><div class="fragment"><div class="line">    VertexId    *reference_component_ids        =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line">    VertexId    *h_component_ids                =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line">    VertexId    *reference_check                =</div>
<div class="line">        (g_quick) ? NULL : reference_component_ids;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ref_num_components             = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate CC enactor</span></div>
<div class="line">    CCEnactor&lt;INSTRUMENT&gt; cc_enactor(g_verbose);</div>
</div><!-- fragment --></p>
<p>In the next step, we create a pointer of the <code>CCProblem</code> type. The <a class="el" href="group___public_interface.html#gadcdac365c220d7e73d301f160971105f" title="CCProblem initialization. ">gunrock::app::cc::CCProblem::Init()</a> function will first copy all the graph-related data from CPU to GPU and then initialize other data members in <a class="el" href="structgunrock_1_1app_1_1cc_1_1_c_c_problem_1_1_data_slice.html" title="Data slice structure which contains CC problem specific data. ">gunrock::app::cc::CCProblem::DataSlice</a>. After this we will be ready to run the graph algorithm on the GPU.</p>
<p><div class="fragment"><div class="line">    CCProblem_T *cc_problem = <span class="keyword">new</span> CCProblem_T;</div>
<div class="line">    util::GRError(cc_problem-&gt;Init(</div>
<div class="line">            g_stream_from_host,</div>
<div class="line">            graph,</div>
<div class="line">            num_gpus), <span class="stringliteral">&quot;CC Problem Initialization Failed&quot;</span>, __FILE__, __LINE__);</div>
</div><!-- fragment --></p>
<p>We next compute the reference solution for CC on the CPU, storing the result in <code>reference_check</code>.</p>
<p><div class="fragment"><div class="line">    <span class="comment">// Compute reference CPU CC solution for source-distance</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (reference_check != NULL)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;compute ref value\n&quot;</span>);</div>
<div class="line">        ref_num_components = <a class="code" href="test__cc_8cu.html#afd4823d968f6198e637586c43db80bf5">RefCPUCC</a>(</div>
<div class="line">            graph.row_offsets,</div>
<div class="line">            graph.column_indices,</div>
<div class="line">            graph.nodes,</div>
<div class="line">            reference_check);</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>Now we can run the connected component primitive on the GPU. To record the kernel running time, simply define a <code>gpu_timer</code> of <code>GpuTimer</code> type. Note that we need to call the <a class="el" href="group___public_interface.html#ga17d86b3625796bb978d8ee376e744c07" title="Performs any initialization work needed for CC problem type. Must be called prior to each CC run...">gunrock::app::cc::CCProblem::Reset()</a> function before the <code>Enact</code> function to reset values in <a class="el" href="structgunrock_1_1app_1_1cc_1_1_c_c_problem_1_1_data_slice.html" title="Data slice structure which contains CC problem specific data. ">gunrock::app::cc::CCProblem::DataSlice</a>. The <a class="el" href="group___public_interface.html#ga061f684201d94f3dee9fb7bcc0222176" title="Enact Kernel Entry, specify KernelPolicy. ">gunrock::app::cc::CCEnactor::Enact()</a> takes a pointer of <a class="el" href="structgunrock_1_1app_1_1cc_1_1_c_c_problem.html" title="Connected Component Problem structure stores device-side vectors for doing connected component comput...">gunrock::app::cc::CCProblem</a> type as the input, runs the connected component primitive, and stores the result in <a class="el" href="structgunrock_1_1app_1_1cc_1_1_c_c_problem_1_1_data_slice.html#a606639c69ad2794abf03c80b35957496">gunrock::app::cc::CCProblem::DataSlice::d_component_ids</a>. We store the GPU running time in a <code>float</code> variable <code>elapsed</code>.</p>
<p><div class="fragment"><div class="line">    <span class="comment">// Perform CC</span></div>
<div class="line">    GpuTimer gpu_timer;</div>
<div class="line"></div>
<div class="line">    util::GRError(cc_problem-&gt;Reset(cc_enactor.GetFrontierType()), <span class="stringliteral">&quot;CC Problem Data Reset Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">    gpu_timer.Start();</div>
<div class="line">    util::GRError(cc_enactor.Enact(cc_problem, max_grid_size), <span class="stringliteral">&quot;CC Problem Enact Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">    gpu_timer.Stop();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> elapsed = gpu_timer.ElapsedMillis();</div>
</div><!-- fragment --></p>
<p>After the <code>Enact</code> function, we need to copy the result from the <code>cc_problem</code> data structure on the GPU into <code>h_component_ids</code>. We can further call <a class="el" href="group___public_interface.html#gadfff5070a7e802070a1cae1583cd7939" title="Compute histogram for component ids. ">gunrock::app::cc::CCProblem::ComputeCCHistogram()</a> to compute the histogram for the connected components of the graph. Finally we can run some validation code, get the top 10 largest connected components, and print their root node ids. <a class="el" href="simple__example_8cu.html#a61d779ff2d4b978ff1d96f5df14953d0" title="Displays the CC result (i.e., number of components) ">DisplayCCSolution()</a> will print the component ids of the first 40 nodes for testing purpose. Now we can set the source node for Breadth-First Search as the root of the largest connected component.</p>
<p><div class="fragment"><div class="line">    util::GRError(cc_problem-&gt;Extract(h_component_ids), <span class="stringliteral">&quot;CC Problem Data Extraction Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> num_errors = 0;</div>
<div class="line">    <span class="comment">// Validity</span></div>
<div class="line">    <span class="keywordflow">if</span> (ref_num_components == cc_problem-&gt;num_components)</div>
<div class="line">        printf(<span class="stringliteral">&quot;CORRECT.\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        printf(<span class="stringliteral">&quot;INCORRECT. Ref Component Count: %d, &quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;GPU Computed Component Count: %d\n&quot;</span>,</div>
<div class="line">               ref_num_components, cc_problem-&gt;num_components);</div>
<div class="line">        printf(<span class="stringliteral">&quot;TEST FAILED\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute size and root of each component</span></div>
<div class="line">    VertexId        *h_roots            =</div>
<div class="line">        <span class="keyword">new</span> VertexId[cc_problem-&gt;num_components];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    *h_histograms       =</div>
<div class="line">        <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[cc_problem-&gt;num_components];</div>
<div class="line"></div>
<div class="line">    cc_problem-&gt;ComputeCCHistogram(h_component_ids, h_roots, h_histograms);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Display Solution</span></div>
<div class="line">    <a class="code" href="simple__example_8cu.html#a61d779ff2d4b978ff1d96f5df14953d0">DisplayCCSolution</a>(h_component_ids, graph.nodes, ref_num_components);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> CcList&lt;VertexId&gt; CcListType;</div>
<div class="line">    <span class="comment">//sort the components by size</span></div>
<div class="line">    CcListType *cclist =</div>
<div class="line">        (CcListType*)malloc(<span class="keyword">sizeof</span>(CcListType) * ref_num_components);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ref_num_components; ++i)</div>
<div class="line">    {</div>
<div class="line">        cclist[i].root = h_roots[i];</div>
<div class="line">        cclist[i].histogram = h_histograms[i];</div>
<div class="line">    }</div>
<div class="line">    std::stable_sort(cclist, cclist + ref_num_components, CCCompare&lt;CcListType&gt;);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Print out at most top 10 largest components</span></div>
<div class="line">    <span class="keywordtype">int</span> top = (ref_num_components &lt; 10) ? ref_num_components : 10;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Top %d largest components:\n&quot;</span>, top);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; top; ++i)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;CC ID: %d, CC Root: %d, CC Size: %d\n&quot;</span>,</div>
<div class="line">               i, cclist[i].root, cclist[i].histogram);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    printf(<span class="stringliteral">&quot;GPU Connected Component finished in %lf msec.\n&quot;</span>, elapsed);</div>
<div class="line"></div>
<div class="line">    VertexId src = cclist[0].root;      <span class="comment">// Set the root of the largest</span></div>
</div><!-- fragment --></p>
<p>The final step of a graph primitive process is cleanup. Note we only need to delete the problem object; its destructor function will release the device memory for us. We finally call <code>cudaDeviceSynchronize</code> to make sure the GPU device has completed all preceding requested tasks.</p>
<p><div class="fragment"><div class="line">    <span class="keyword">delete</span> cc_problem;</div>
<div class="line">    <span class="keyword">delete</span>[] h_roots;</div>
<div class="line">    <span class="keyword">delete</span>[] h_histograms;</div>
<div class="line">    free(cclist);</div>
<div class="line">    free(reference_component_ids);</div>
<div class="line">    free(h_component_ids);</div>
<div class="line"></div>
<div class="line">    cudaDeviceSynchronize();</div>
</div><!-- fragment --></p>
<p>For Breadth-First Search primitive, the process is the same. We first define a pointer to the <a class="el" href="structgunrock_1_1app_1_1bfs_1_1_b_f_s_problem.html" title="Breadth-First Search Problem structure stores device-side vectors for doing BFS computing on the GPU...">gunrock::app::bfs::BFSProblem</a> type. Here we set the template argument <code>MARK_PREDECESSORS</code> to <code>true</code> to specify that we want the algorithm to keep both the distances from source and the predecessor node id as the result.</p>
<p><div class="fragment"><div class="line">    <span class="keyword">typedef</span> BFSProblem&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        <span class="keyword">true</span>,                <span class="comment">// Set MARK_PREDECESSORS flag true</span></div>
<div class="line">        <span class="keyword">false</span>,                <span class="comment">// Set to enable idempotent operation</span></div>
<div class="line">        <span class="keyword">false</span>&gt; BFSProblem_T; <span class="comment">// does not use double buffer</span></div>
</div><!-- fragment --></p>
<p>Then we allocate a host-side array for doing a reference check and storing GPU-computed results. For BFS, the results include <a class="el" href="structgunrock_1_1app_1_1bfs_1_1_b_f_s_problem_1_1_data_slice.html#af5c56c4ac4a0b9d50034d0619b92e522">gunrock::app::bfs::BFSProblem::DataSlice::d_labels</a> and <a class="el" href="structgunrock_1_1app_1_1bfs_1_1_b_f_s_problem_1_1_data_slice.html#a5a3371adc34dc1cb09bf4b7b70d6d95d">gunrock::app::bfs::BFSProblem::DataSlice::d_preds</a>. We then define the BFS enactor object of the <a class="el" href="classgunrock_1_1app_1_1bfs_1_1_b_f_s_enactor.html" title="BFS problem enactor class. ">gunrock::app::bfs::BFSEnactor</a> type, initialize the <a class="el" href="structgunrock_1_1app_1_1bfs_1_1_b_f_s_problem.html" title="Breadth-First Search Problem structure stores device-side vectors for doing BFS computing on the GPU...">gunrock::app::bfs::BFSProblem</a> type BFS problem object, and run the CPU and the GPU BFS reference algorithm, similar to what we did in the CC graph primitive. If the template argument <code>INSTRUMENT</code> is set, we can use the <code>GetStatistics</code> function to get total elements queued, average kernel duty (a load balancing metric), and for BFS, the searching depth from the enactor object. In this example, we only show how to get statistical data and display it for BFS problem, but all three graph primitives have <code>GetStatistics</code> functions as public interfaces users can call.</p>
<p><div class="fragment"><div class="line">    VertexId *reference_labels =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line">    VertexId *h_labels         =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line">    reference_check            =</div>
<div class="line">        (g_quick) ? NULL : reference_labels;</div>
<div class="line">    VertexId *h_preds          =</div>
<div class="line">        (VertexId*)malloc(<span class="keyword">sizeof</span>(VertexId) * graph.nodes);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate BFS enactor</span></div>
<div class="line">    BFSEnactor&lt;INSTRUMENT&gt; bfs_enactor(g_verbose);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate problem on GPU</span></div>
<div class="line">    BFSProblem_T *bfs_problem = <span class="keyword">new</span> BFSProblem_T;</div>
<div class="line">    util::GRError(bfs_problem-&gt;Init(</div>
<div class="line">            g_stream_from_host,</div>
<div class="line">            graph,</div>
<div class="line">            num_gpus), <span class="stringliteral">&quot;BFS Problem Initialization Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Compute reference CPU BFS solution for source-distance</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (reference_check != NULL)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;compute ref value\n&quot;</span>);</div>
<div class="line">        <a class="code" href="test__bfs_8cu.html#ad308626cfd43d1e920ad592e971d14cf">SimpleReferenceBfs</a>(</div>
<div class="line">            graph,</div>
<div class="line">            reference_check,</div>
<div class="line">            src);</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="struct_stats.html">Stats</a> *stats = <span class="keyword">new</span> <a class="code" href="struct_stats.html">Stats</a>(<span class="stringliteral">&quot;GPU BFS&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span>           total_queued = 0;</div>
<div class="line">    VertexId            search_depth = 0;</div>
<div class="line">    <span class="keywordtype">double</span>              avg_duty = 0.0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Perform BFS</span></div>
<div class="line"></div>
<div class="line">    util::GRError(bfs_problem-&gt;Reset(src, bfs_enactor.GetFrontierType(),</div>
<div class="line">                                    max_queue_sizing), <span class="stringliteral">&quot;BFS Problem Data Reset Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">    gpu_timer.Start();</div>
<div class="line">    util::GRError(bfs_enactor.Enact(context, bfs_problem, src, max_grid_size), <span class="stringliteral">&quot;BFS Problem Enact Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">    gpu_timer.Stop();</div>
<div class="line"></div>
<div class="line">    bfs_enactor.GetStatistics(total_queued, search_depth, avg_duty);</div>
<div class="line"></div>
<div class="line">    elapsed = gpu_timer.ElapsedMillis();</div>
</div><!-- fragment --></p>
<p>When we finish the BFS algorithm, we copy the results from GPU to CPU using <code>Extract</code> function. We also use <a class="el" href="group___public_interface.html#gaa265a7f86ad4b06dcb7b5e75869fe7ad" title="Compares the equivalence of two arrays. If incorrect, print the location of the first incorrect value...">gunrock::util::CompareResults()</a> to validate the computed results we get. Here we only do this for the distance from the source value of each node. The <code><a class="el" href="simple__example_8cu.html#a294e71af0083dbbf14b90c514d93960d" title="Displays the BFS result (i.e., distance from source) ">DisplayBFSSolution()</a></code> function will display the distance from source value and the predecessor id value for the first 40 nodes in the graph. The <code><a class="el" href="simple__example_8cu.html#a73cc366e897f1aee0f0025548e7c2d82" title="Displays timing and correctness statistics for BFS. ">DisplayBFSStats()</a></code> function will display the total queued element number, the maximum search depth, and the average GPU kernel function duty. Users can also implement their own version of these display functions.</p>
<p><div class="fragment"><div class="line">    util::GRError(bfs_problem-&gt;Extract(h_labels, h_preds), <span class="stringliteral">&quot;BFS Problem Data Extraction Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Verify the result</span></div>
<div class="line">    <span class="keywordflow">if</span> (reference_check != NULL) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Validity: &quot;</span>);</div>
<div class="line">        num_errors += <a class="code" href="group___public_interface.html#gaa265a7f86ad4b06dcb7b5e75869fe7ad">CompareResults</a>(h_labels, reference_check, graph.nodes);</div>
<div class="line">    }</div>
<div class="line">    printf(<span class="stringliteral">&quot;\nFirst 40 labels of the GPU result.&quot;</span>);</div>
<div class="line">    <span class="comment">// Display Solution</span></div>
<div class="line">    <a class="code" href="simple__example_8cu.html#a294e71af0083dbbf14b90c514d93960d">DisplayBFSSolution</a>(h_labels, h_preds, graph.nodes, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="simple__example_8cu.html#a73cc366e897f1aee0f0025548e7c2d82">DisplayBFSStats</a>(</div>
<div class="line">        *stats,</div>
<div class="line">        src,</div>
<div class="line">        h_labels,</div>
<div class="line">        graph,</div>
<div class="line">        elapsed,</div>
<div class="line">        search_depth,</div>
<div class="line">        total_queued,</div>
<div class="line">        avg_duty);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cleanup</span></div>
<div class="line">    <span class="keyword">delete</span> stats;</div>
<div class="line">    <span class="keyword">delete</span> bfs_problem;</div>
<div class="line">    free(reference_labels);</div>
<div class="line">    free(h_labels);</div>
<div class="line">    free(h_preds);</div>
<div class="line"></div>
<div class="line">    cudaDeviceSynchronize();</div>
</div><!-- fragment --></p>
<p>The third graph primitive we want to run is Brandes's Betweenness Centrality. We first set the source node to -1 to inform the algorithm to compute the BC values for all nodes in the graph. The preparation steps are similar to those of the previous two primitives.</p>
<p><div class="fragment"><div class="line">    src = -1;</div>
<div class="line">    <span class="keyword">typedef</span> BCProblem&lt;</div>
<div class="line">        VertexId,</div>
<div class="line">        SizeT,</div>
<div class="line">        Value,</div>
<div class="line">        <span class="keyword">true</span>,               <span class="comment">// MARK_PREDECESSOR</span></div>
<div class="line">        <span class="keyword">false</span>&gt; BCProblem_T; <span class="comment">//does not use double buffer</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate host-side array (for both reference and gpu-computed results)</span></div>
<div class="line">    Value *reference_bc_values       =</div>
<div class="line">        (Value*)malloc(<span class="keyword">sizeof</span>(Value) * graph.nodes);</div>
<div class="line">    Value *h_bc_values               =</div>
<div class="line">        (Value*)malloc(<span class="keyword">sizeof</span>(Value) * graph.nodes);</div>
<div class="line">    Value *reference_check_bc_values = (g_quick) ? NULL : reference_bc_values;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate BC enactor</span></div>
<div class="line">    BCEnactor&lt;INSTRUMENT&gt; bc_enactor(g_verbose);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate problem on GPU</span></div>
<div class="line">    BCProblem_T *bc_problem = <span class="keyword">new</span> BCProblem_T;</div>
<div class="line">    util::GRError(bc_problem-&gt;Init(</div>
<div class="line">            g_stream_from_host,</div>
<div class="line">            graph,</div>
<div class="line">            num_gpus), <span class="stringliteral">&quot;BC Problem Initialization Failed&quot;</span>, __FILE__, __LINE__);</div>
</div><!-- fragment --></p>
<p>In the actual computing process, we need to manually iterate over all the nodes in the graph. We design the BC primitive this way to provide more flexible use of BC value computing. For example, you can build your own approximate BC algorithm using this primitive.</p>
<p><div class="fragment"><div class="line">    VertexId start_src = 0;</div>
<div class="line">    VertexId end_src = graph.nodes;</div>
<div class="line"></div>
<div class="line">    gpu_timer.Start();</div>
<div class="line">    <span class="keywordflow">for</span> (VertexId i = start_src; i &lt; end_src; ++i)</div>
<div class="line">    {</div>
<div class="line">        util::GRError(bc_problem-&gt;Reset(i, bc_enactor.GetFrontierType(),</div>
<div class="line">                                       max_queue_sizing), <span class="stringliteral">&quot;BC Problem Data Reset Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">        util::GRError(bc_enactor.Enact(context, bc_problem, i, max_grid_size), <span class="stringliteral">&quot;BC Problem Enact Failed&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">    }</div>
</div><!-- fragment --></p>
<p>Note after the algorithm we need to call <a class="el" href="group___public_interface.html#ga1126888b2cf4869c00b90c7adace53c4" title="Scale each element in a device vector to a certain factor. ">gunrock::util::MemsetScaleKernel()</a> for normalization. Because we consider the graph as undirected, each node's BC value is thus doubled, so we need to halve them to get the correct values.</p>
<p><div class="fragment"><div class="line">    util::MemsetScaleKernel&lt;&lt;&lt;128, 128&gt;&gt;&gt;</div>
</div><!-- fragment --></p>
<p>The final step is the cleanup code for the BC primitive.</p>
<p><div class="fragment"><div class="line">    <span class="keyword">delete</span> bc_problem;</div>
<div class="line">    free(reference_bc_values);</div>
<div class="line">    free(h_bc_values);</div>
<div class="line"></div>
<div class="line">    cudaDeviceSynchronize();</div>
</div><!-- fragment --></p>
<p>We hope this can help you to integrate Gunrock into your project. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 13 2014 17:20:56 for gunrock by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
